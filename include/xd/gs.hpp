#ifndef GS_HPP
#define GS_HPP

const char* gs =
"#version 330 core\n"
"\n"
"uniform vec2 uWIN_SCALE;\n"
"\n"
"layout(triangles) in;\n"
"layout(triangle_strip, max_vertices=3) out;\n"
"\n"
"in Vertex {\n"
"	vec2 uv;\n"
"	vec3 color;\n"
"	float excludeEdge;\n"
"} vertex[];\n"
"\n"
"out vec2 vUV;\n"
"out vec3 vColor;\n"
"noperspective out vec3 vDist;\n"
"\n"
"const float MEW = 100.0; // max edge width\n"
"\n"
"float cross(vec2 a, vec2 b) {\n"
"	return a.x * b.y - a.y * b.x;\n"
"}\n"
"\n"
"void main() {\n"
"	vec2 v0 = uWIN_SCALE * gl_in[0].gl_Position.xy / gl_in[0].gl_Position.w;\n"
"	vec2 v1 = uWIN_SCALE * gl_in[1].gl_Position.xy / gl_in[1].gl_Position.w;\n"
"	vec2 v2 = uWIN_SCALE * gl_in[2].gl_Position.xy / gl_in[2].gl_Position.w;\n"
"	vec2 e[3];\n"
"	e[0] = v2 - v1;\n"
"	e[1] = v2 - v0;\n"
"	e[2] = v1 - v0;\n"
"	float area2 = abs(cross(e[0], e[1]));\n"
"\n"
"	for (int i = 0; i < gl_in.length(); i++) {\n"
"		vUV = vertex[i].uv;\n"
"		vColor = vertex[i].color;\n"
"		vDist = vec3(0.0);\n"
"		vDist[i] = area2 / length(e[i]);\n"
"		vDist[(i + 1) % gl_in.length()] = vertex[(i + 1) % gl_in.length()].excludeEdge * MEW;\n"
"		vDist[(i + 2) % gl_in.length()] = vertex[(i + 2) % gl_in.length()].excludeEdge * MEW;\n"
"		gl_Position = gl_in[i].gl_Position;\n"
"		EmitVertex();\n"
"	}\n"
"}\n"
;

#endif /* GS_HPP */
